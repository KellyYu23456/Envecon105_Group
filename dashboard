dashboard.py
# streamlit_app.py
import io
import re
import zipfile
import json
import numpy as np
import pandas as pd
import requests
import streamlit as st
import plotly.express as px
import plotly.graph_objects as go
from statsmodels.nonparametric.smoothers_lowess import lowess

st.set_page_config(page_title="CO₂, Energy, GDP & Temperature — Dashboard", layout="wide")

# ────────────────────────────────────────────────────────────────────────────────
# 0) GitHub RAW file locations (update if your repo/paths change)
# ────────────────────────────────────────────────────────────────────────────────
RAW_URLS = {
    # World Bank zips (each zip contains several CSVs; we will auto-pick the main one)
    "gdp_zip":  "https://github.com/KellyYu23456/Envecon105_Group/raw/main/gdp_global.zip",
    "energy_zip": "https://github.com/KellyYu23456/Envecon105_Group/raw/main/energy_global.zip",

    # Excel files
    "co2_per_capita_xlsx": "https://github.com/KellyYu23456/Envecon105_Group/raw/main/co2_per_capita.xlsx",
    "disasters_xlsx":      "https://github.com/KellyYu23456/Envecon105_Group/raw/main/natural_disasters_china.xlsx",
    "temp_xlsx":           "https://github.com/KellyYu23456/Envecon105_Group/raw/main/temp_mean_china_cru_1901-2024.xlsx",
    "co2_wide_xlsx":       "https://github.com/KellyYu23456/Envecon105_Group/raw/main/yearly_co2_emissions_1000_tonnes.xlsx",
}

# ────────────────────────────────────────────────────────────────────────────────
# 1) Helpers: read Excel from URL, pick CSV from a ZIP on URL, general utils
# ────────────────────────────────────────────────────────────────────────────────
@st.cache_data(show_spinner=False)
def read_excel_from_url(url: str, skiprows=0, na_values=None, sheet_name=0):
    r = requests.get(url, timeout=60)
    r.raise_for_status()
    return pd.read_excel(io.BytesIO(r.content), skiprows=skiprows, na_values=na_values, sheet_name=sheet_name)

@st.cache_data(show_spinner=False)
def zip_member_list(url: str):
    r = requests.get(url, timeout=60)
    r.raise_for_status()
    zf = zipfile.ZipFile(io.BytesIO(r.content))
    return zf.namelist()

def _pick_main_csv(members, prefer_prefix=None):
    """
    Choose the main 'API_...csv' file and ignore 'Metadata_...' CSVs.
    If prefer_prefix is provided (e.g. 'API_NY.GDP' or 'API_EG.USE'), try that first.
    """
    csvs = [m for m in members if m.lower().endswith(".csv")]
    csvs = [m for m in csvs if not m.startswith("Metadata_")] or csvs  # drop metadata if possible
    if prefer_prefix:
        for m in csvs:
            if m.startswith(prefer_prefix):
                return m
    # fallback: first non-metadata CSV
    return csvs[0] if csvs else None

@st.cache_data(show_spinner=False)
def read_zip_csv_from_url(url: str, member_name=None, skiprows=3, prefer_prefix=None):
    r = requests.get(url, timeout=60)
    r.raise_for_status()
    zf = zipfile.ZipFile(io.BytesIO(r.content))

    if member_name is None:
        # auto-pick main CSV
        member_name = _pick_main_csv(zf.namelist(), prefer_prefix=prefer_prefix)
    with zf.open(member_name) as f:
        return pd.read_csv(f, skiprows=skiprows)

def to_int_year_col(df, col="Year"):
    df[col] = pd.to_numeric(df[col], errors="coerce").astype("Int64")
    return df

# ────────────────────────────────────────────────────────────────────────────────
# 2) Load + wrangle source tables to a unified long table
# ────────────────────────────────────────────────────────────────────────────────
@st.cache_data(show_spinner=False)
def load_all():
    # 2a) GDP per-capita growth (%), wide → long: (Country, Year, GDP_growth)
    gdp_wide = read_zip_csv_from_url(
        RAW_URLS["gdp_zip"], skiprows=4, prefer_prefix="API_NY.GDP.PCAP.KD.ZG"
    )
    gdp_long = (gdp_wide
                .drop(columns=[c for c in gdp_wide.columns if "Unnamed" in c])
                .rename(columns={"Country Name": "Country"})
                .melt(id_vars=["Country"], var_name="Year", value_name="GDP_growth"))
    gdp_long = to_int_year_col(gdp_long)
    gdp_long["Indicator"] = "GDP"
    gdp_long["Label"] = "GDP per capita (yearly growth, %)"

    # 2b) Energy use (kg oil eq. per person), wide → long
    energy_wide = read_zip_csv_from_url(
        RAW_URLS["energy_zip"], skiprows=4, prefer_prefix="API_EG.USE.PCAP.KG.OE"
    )
    energy_long = (energy_wide
                   .drop(columns=[c for c in energy_wide.columns if "Unnamed" in c])
                   .rename(columns={"Country Name": "Country"})
                   .melt(id_vars=["Country"], var_name="Year", value_name="Energy_use"))
    energy_long = to_int_year_col(energy_long)
    energy_long["Indicator"] = "Energy"
    energy_long["Label"] = "Energy Use (kg oil eq. per person)"

    # 2c) CO₂ per capita (tonnes/person), wide → long
    co2pc_wide = read_excel_from_url(RAW_URLS["co2_per_capita_xlsx"])
    # assume first col is country; years as columns
    cn_col = co2pc_wide.columns[0]
    co2pc_long = (co2pc_wide
                  .rename(columns={cn_col: "Country"})
                  .melt(id_vars=["Country"], var_name="Year", value_name="Per_Capita_Emissions"))
    co2pc_long = to_int_year_col(co2pc_long)
    co2pc_long["Indicator"] = "Per_Capita_Emissions"
    co2pc_long["Label"] = "CO₂ per Capita (tonnes/person)"

    # 2d) Total CO₂ (1000 tonnes), wide → long
    co2_wide = read_excel_from_url(RAW_URLS["co2_wide_xlsx"])
    # assume first col is 'country' or similar:
    first_col = co2_wide.columns[0]
    co2_long = (co2_wide
                .rename(columns={first_col: "Country"})
                .melt(id_vars=["Country"], var_name="Year", value_name="Emissions"))
    co2_long = to_int_year_col(co2_long)
    co2_long["Indicator"] = "Emissions"
    co2_long["Label"] = "CO₂ Emissions (Metric Tons)"
    # convert from 'thousand tonnes' -> metric tons if needed.
    # Your notebook used metric tons in plots. If your file is in thousands, multiply by 1000:
    # co2_long["Emissions"] = co2_long["Emissions"] * 1000.0

    # 2e) China temperature (°C → °F), build (Year, Temperature)
    # many CRU sheets have 3–4 metadata rows; we already set skiprows=4 above in notebooks.
    temp_df = read_excel_from_url(RAW_URLS["temp_xlsx"], skiprows=4, na_values=["-99"])
    # The CRU format is wide by year-month labels; we’ll pick annual mean if available
    # Try to locate a column that looks like years (e.g. '1901-07', etc.) and compute annual mean,
    # or if there is a ready "Year" and "Temperature" column pair.
    # Fallback: columns that look like 'YYYY-07' etc.
    yearcols = [c for c in temp_df.columns if re.match(r"^\d{4}(-\d{2})?$", str(c))]
    if len(yearcols) == 0:
        # Some files put years as row index; try transpose
        temp_df = temp_df.T
        temp_df.reset_index(inplace=True)
        temp_df.columns = ["Year", "Temperature_C"]
        temp_df = temp_df[temp_df["Year"].astype(str).str.match(r"^\d{4}$")]
        temp_df["Year"] = temp_df["Year"].astype(int)
    else:
        # compute row-wise annual mean across the year columns
        # Often there is one row; if so, just melt
        tmp = temp_df[yearcols]
        ann = tmp.T.reset_index()
        ann.columns = ["Year", "Temperature_C"]
        ann["Year"] = ann["Year"].str.slice(0, 4).astype(int)
        # Drop duplicates like different months per same year by averaging:
        ann = ann.groupby("Year", as_index=False)["Temperature_C"].mean()
        temp_df = ann

    temp_df["Temperature"] = temp_df["Temperature_C"] * 9/5 + 32
    temp_df = temp_df[["Year", "Temperature"]].dropna()
    temp_df["Country"] = "China"
    temp_df["Indicator"] = "Temperature"
    temp_df["Label"] = "China Annual Average Temperature (°F)"

    # 2f) China disasters (optional in dashboard, but we keep in unified table)
    try:
        dis_df = read_excel_from_url(RAW_URLS["disasters_xlsx"])
        # Make (Year, value) if possible:
        first_col = dis_df.columns[0]
        dis_long = (dis_df
                    .rename(columns={first_col: "Year"})
                    .melt(id_vars=["Year"], var_name="Disaster_Type", value_name="Disasters"))
        dis_long["Country"] = "China"
        dis_long["Indicator"] = "Disasters"
        dis_long["Label"] = "China Natural Disasters (count)"
        dis_long = to_int_year_col(dis_long, "Year")
        dis_long = dis_long.groupby(["Country", "Year", "Indicator", "Label"], as_index=False)["Disasters"].sum()
    except Exception:
        dis_long = pd.DataFrame(columns=["Country","Year","Indicator","Label","Disasters"])

    # ───── Assemble unified long table ─────
    # Stack CO2, Energy, GDP
    base = (
        co2_long.rename(columns={"Emissions": "Value"})[["Country","Year","Indicator","Label","Value"]]
        .append(energy_long.rename(columns={"Energy_use": "Value"})[["Country","Year","Indicator","Label","Value"]])
        .append(gdp_long.rename(columns={"GDP_growth": "Value"})[["Country","Year","Indicator","Label","Value"]])
        .reset_index(drop=True)
    )

    # Append China-only series: temperature & disasters
    temp_cn = temp_df.rename(columns={"Temperature": "Value"})[["Country","Year","Indicator","Label","Value"]]
    dis_cn = dis_long.rename(columns={"Disasters": "Value"})[["Country","Year","Indicator","Label","Value"]]
    data_long = pd.concat([base, temp_cn, dis_cn], ignore_index=True)

    # Also keep wide tables we need for some charts:
    return {
        "data_long": data_long,
        "co2_long": co2_long,
        "co2_per_capita_long": co2pc_long,
        "gdp_long": gdp_long,
        "energy_long": energy_long,
        "temp_china": temp_df[["Year","Temperature"]],
    }

D = load_all()
data_long = D["data_long"]
co2_long = D["co2_long"]
co2pc_long = D["co2_per_capita_long"]
gdp_long = D["gdp_long"]
energy_long = D["energy_long"]
temp_china = D["temp_china"]

# Region flag for faceting
data_long["Region"] = np.where(data_long["Country"].eq("China"), "China", "Rest of the World")

# ────────────────────────────────────────────────────────────────────────────────
# 3) Sidebar controls
# ────────────────────────────────────────────────────────────────────────────────
st.sidebar.header("Controls")
default_country = "China" if "China" in co2_long["Country"].unique() else co2_long["Country"].iloc[0]
country = st.sidebar.selectbox("Highlight country", sorted(co2_long["Country"].dropna().unique()), index=sorted(co2_long["Country"].dropna().unique()).index(default_country))
yr_min = int(co2_long["Year"].min())
yr_max = int(co2_long["Year"].max())
year_range = st.sidebar.slider("Year range (for most plots)", min_value=yr_min, max_value=yr_max, value=(max(1900, yr_min), yr_max), step=1)
smooth_frac = st.sidebar.slider("LOESS smoothing (for temp/emissions small chart)", 0.1, 0.6, 0.35, 0.05)
log_heat = st.sidebar.checkbox("Log scale in heatmap", value=True)

st.title("CO₂, Energy, GDP, and Temperature — Interactive Dashboard")

# ────────────────────────────────────────────────────────────────────────────────
# 4) Tabs
# ────────────────────────────────────────────────────────────────────────────────
tab1, tab2, tab3, tab4, tab5 = st.tabs([
    "Global Overview",
    "Country Lines",
    "Top-10 Heatmap",
    "Faceted (China vs Rest)",
    "China Deep-Dives",
])

# ────────────────────────────────────────────────────────────────────────────────
# Tab 1: Global overview
# ────────────────────────────────────────────────────────────────────────────────
with tab1:
    st.subheader("World CO₂ Emissions over Time")
    # Aggregate global:
    world = (co2_long.groupby("Year", as_index=False)["Emissions"].sum()
             .query("@year_range[0] <= Year <= @year_range[1]"))
    fig = px.line(world, x="Year", y="Emissions",
                  labels={"Emissions": "CO₂ Emissions (Metric Tons)"}, height=420)
    st.plotly_chart(fig, use_container_width=True)

# ────────────────────────────────────────────────────────────────────────────────
# Tab 2: Country lines (highlight selected)
# ────────────────────────────────────────────────────────────────────────────────
with tab2:
    st.subheader(f"Country CO₂ Emissions per Year (highlight: {country})")
    sub = co2_long.query("@year_range[0] <= Year <= @year_range[1]").copy()

    # draw gray lines for others, colored line for selected
    others = sub[sub["Country"] != country]
    focus = sub[sub["Country"] == country]

    fig = go.Figure()
    for name, g in others.groupby("Country"):
        fig.add_trace(go.Scatter(x=g["Year"], y=g["Emissions"],
                                 mode="lines", line=dict(color="lightgray", width=1),
                                 showlegend=False, hovertext=name))
    if not focus.empty:
        fig.add_trace(go.Scatter(x=focus["Year"], y=focus["Emissions"],
                                 mode="lines", name=country,
                                 line=dict(color="#2f6df6", width=3)))
    fig.update_layout(height=500, xaxis_title="Year", yaxis_title="CO₂ Emissions (Metric Tons)")
    st.plotly_chart(fig, use_container_width=True)

# ────────────────────────────────────────────────────────────────────────────────
# Tab 3: Top-10 emitters heatmap (log scale)
# ────────────────────────────────────────────────────────────────────────────────
with tab3:
    st.subheader("Top-10 CO₂ Emitters — Heatmap (1900+)")
    last_year = int(co2_long["Year"].max())
    top10 = (co2_long.query("Year == @last_year")
                      .nlargest(10, "Emissions")["Country"].tolist())
    tile = (co2_long.query("Country in @top10 and Year >= 1900")
                    .pivot_table(index="Country", columns="Year", values="Emissions", aggfunc="sum")
                    .reindex(index=top10))
    Z = tile.values.astype(float)
    if log_heat:
        Z = np.where(Z > 0, np.log(Z), np.nan)
    fig = px.imshow(Z, aspect="auto",
                    x=tile.columns, y=tile.index,
                    labels=dict(color=("Ln(CO₂ Emissions)" if log_heat else "CO₂ Emissions")))
    fig.update_layout(height=520)
    st.plotly_chart(fig, use_container_width=True)

# ────────────────────────────────────────────────────────────────────────────────
# Tab 4: Faceted (China vs Rest): Emissions, Energy, GDP
# ────────────────────────────────────────────────────────────────────────────────
with tab4:
    st.subheader("Emissions, Energy, GDP — China vs Rest of the World")
    df = data_long.query("@year_range[0] <= Year <= @year_range[1] and Indicator in ['Emissions','Energy','GDP']").copy()
    # Light lines of countries, grouped by Region
    fig = px.line(df, x="Year", y="Value", color="Region", facet_row="Indicator",
                  facet_row_spacing=0.07, height=800)
    fig.update_traces(line=dict(width=1))
    st.plotly_chart(fig, use_container_width=True)

# ────────────────────────────────────────────────────────────────────────────────
# Tab 5: China deep-dives (1980–2014 focus + two pair plots)
# ────────────────────────────────────────────────────────────────────────────────
with tab5:
    c1, c2 = st.columns([1.2, 1])
    with c1:
        st.markdown("### China — Emissions & Temperature (1980–2014)")
        span_min, span_max = 1980, min(2014, int(co2_long["Year"].max()))
        ch_em = (co2_long.query("Country=='China' and @span_min <= Year <= @span_max")
                           .sort_values("Year")[["Year","Emissions"]])
        ch_t = (temp_china.query("@span_min <= Year <= @span_max")
                          .sort_values("Year")[["Year","Temperature"]])
        # Emissions line + points
        fig1 = px.scatter(ch_em, x="Year", y="Emissions", title="CO₂ Emissions (Metric Tons)")
        fig1.add_traces(px.line(ch_em, x="Year", y="Emissions").data)
        # Temperature line (LOESS via statsmodels)
        lo = lowess(ch_t["Temperature"], ch_t["Year"], frac=smooth_frac, return_sorted=True)
        ch_t_smooth = pd.DataFrame(lo, columns=["Year","Temperature"])
        fig2 = px.scatter(ch_t, x="Year", y="Temperature", title="Temperature (°F)")
        fig2.add_traces(px.line(ch_t_smooth, x="Year", y="Temperature").data)

        st.plotly_chart(fig1, use_container_width=True)
        st.plotly_chart(fig2, use_container_width=True)

    with c2:
        st.markdown("### China — Total CO₂ vs CO₂ per Capita (year color)")
        ch_tot = co2_long.query("Country=='China' and Year>=1900")[["Year","Emissions"]]
        ch_pc  = co2pc_long.query("Country=='China'")[["Year","Per_Capita_Emissions"]]
        scat = (ch_tot.merge(ch_pc, on="Year", how="inner")
                     .dropna(subset=["Emissions","Per_Capita_Emissions"]))
        fig3 = px.scatter(scat, x="Emissions", y="Per_Capita_Emissions", color="Year",
                          color_continuous_scale="Viridis",
                          labels={"Emissions":"Total CO₂ (Metric Tons)",
                                  "Per_Capita_Emissions":"CO₂ per Capita (tonnes/person)"},
                          height=520)
        # Reference proportional line (best-fit through origin)
        beta = (scat["Emissions"] * scat["Per_Capita_Emissions"]).sum() / (scat["Emissions"]**2).sum()
        xline = np.linspace(scat["Emissions"].min(), scat["Emissions"].max(), 200)
        fig3.add_trace(go.Scatter(x=xline, y=beta*xline, mode="lines",
                                  line=dict(color="red", dash="dash"), name="Proportional fit"))
        st.plotly_chart(fig3, use_container_width=True)

    st.markdown("---")
    st.markdown("### China — CO₂ per Capita vs GDP per Capita Growth (%)")
    ch_g = gdp_long.query("Country=='China'")[["Year","GDP_growth"]]
    ch_pc = co2pc_long.query("Country=='China'")[["Year","Per_Capita_Emissions"]]
    xy = ch_g.merge(ch_pc, on="Year", how="inner").dropna()
    fig4 = px.scatter(xy, x="GDP_growth", y="Per_Capita_Emissions", color="Year",
                      color_continuous_scale="Viridis",
                      labels={"GDP_growth":"GDP per Capita Growth (%)",
                              "Per_Capita_Emissions":"CO₂ per Capita (tonnes/person)"},
                      height=520, trendline="ols", trendline_color_override="crimson")
    st.plotly_chart(fig4, use_container_width=True)

# Footer
st.caption("Data sources: World Bank (GDP, Energy), OWID/Global CO₂ (Totals & per-capita), CRU (China temperature). "
           "Dashboard replicates & extends your notebooks’ wrangling.")
